name: Deploy to AWS App Runner

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Load App Runner config
        id: config
        run: |
          echo "name=$(yq '.service.name' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "port=$(yq '.service.port' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "cpu=$(yq '.service.cpu' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "memory=$(yq '.service.memory' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "health_path=$(yq '.healthCheck.path' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "health_interval=$(yq '.healthCheck.interval' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "health_timeout=$(yq '.healthCheck.timeout' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "health_healthy=$(yq '.healthCheck.healthyThreshold' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "health_unhealthy=$(yq '.healthCheck.unhealthyThreshold' apprunner-config.yml)" >> $GITHUB_OUTPUT
          echo "java_opts=$(yq '.runtime.javaToolOptions' apprunner-config.yml)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          SERVICE_NAME: ${{ steps.config.outputs.name }}
        run: |
          docker build -t $ECR_REGISTRY/$SERVICE_NAME:$IMAGE_TAG -t $ECR_REGISTRY/$SERVICE_NAME:latest .
          docker push $ECR_REGISTRY/$SERVICE_NAME:$IMAGE_TAG
          docker push $ECR_REGISTRY/$SERVICE_NAME:latest

      - name: Check if App Runner service exists
        id: check-service
        env:
          SERVICE_NAME: ${{ steps.config.outputs.name }}
        run: |
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='$SERVICE_NAME'].ServiceArn" --output text)
          if [ -z "$SERVICE_ARN" ] || [ "$SERVICE_ARN" == "None" ]; then
            echo "exists=false" >> $GITHUB_OUTPUT
          else
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "arn=$SERVICE_ARN" >> $GITHUB_OUTPUT
          fi

      - name: Create App Runner service
        if: steps.check-service.outputs.exists == 'false'
        id: create-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SERVICE_NAME: ${{ steps.config.outputs.name }}
          PORT: ${{ steps.config.outputs.port }}
          CPU: ${{ steps.config.outputs.cpu }}
          MEMORY: ${{ steps.config.outputs.memory }}
          HEALTH_PATH: ${{ steps.config.outputs.health_path }}
          HEALTH_INTERVAL: ${{ steps.config.outputs.health_interval }}
          HEALTH_TIMEOUT: ${{ steps.config.outputs.health_timeout }}
          HEALTH_HEALTHY: ${{ steps.config.outputs.health_healthy }}
          HEALTH_UNHEALTHY: ${{ steps.config.outputs.health_unhealthy }}
          JAVA_OPTS: ${{ steps.config.outputs.java_opts }}
          ROLE_ARN: ${{ secrets.APP_RUNNER_ECR_ROLE_ARN }}
        run: |
          SERVICE_ARN=$(aws apprunner create-service \
            --service-name "$SERVICE_NAME" \
            --source-configuration "{
              \"AuthenticationConfiguration\": {\"AccessRoleArn\": \"$ROLE_ARN\"},
              \"ImageRepository\": {
                \"ImageIdentifier\": \"$ECR_REGISTRY/$SERVICE_NAME:latest\",
                \"ImageRepositoryType\": \"ECR\",
                \"ImageConfiguration\": {
                  \"Port\": \"$PORT\",
                  \"RuntimeEnvironmentVariables\": {\"JAVA_TOOL_OPTIONS\": \"$JAVA_OPTS\"}
                }
              },
              \"AutoDeploymentsEnabled\": false
            }" \
            --instance-configuration "{\"Cpu\": \"$CPU\", \"Memory\": \"$MEMORY\"}" \
            --health-check-configuration "{\"Protocol\": \"HTTP\", \"Path\": \"$HEALTH_PATH\", \"Interval\": $HEALTH_INTERVAL, \"Timeout\": $HEALTH_TIMEOUT, \"HealthyThreshold\": $HEALTH_HEALTHY, \"UnhealthyThreshold\": $HEALTH_UNHEALTHY}" \
            --query 'Service.ServiceArn' --output text)
          echo "arn=$SERVICE_ARN" >> $GITHUB_OUTPUT

      - name: Wait for App Runner service
        if: steps.check-service.outputs.exists == 'false'
        run: |
          SERVICE_ARN="${{ steps.create-service.outputs.arn }}"
          for i in {1..60}; do
            STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.Status' --output text)
            if [ "$STATUS" == "RUNNING" ]; then
              exit 0
            elif [ "$STATUS" == "CREATE_FAILED" ]; then
              exit 1
            fi
            sleep 10
          done
          exit 1

      - name: Deploy to existing App Runner
        if: steps.check-service.outputs.exists == 'true'
        run: |
          aws apprunner start-deployment --service-arn ${{ steps.check-service.outputs.arn }}
